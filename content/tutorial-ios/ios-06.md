# Tutorial 06 - More Mutations

Welcome to the 6th and last exercise in the **iOS Track** of this Apollo Client Tutorial!


## Goal

The **goal** of this exercise is to implement features for updating and deleting existing Pokemons from the Pokedex. This will give you more familiarity with using mutations.


## Introduction

Open the directory that contains the 6th exercise (`exercise-06`) and open `pokedex-apollo.xcworkspace`. It already contains a running version of the code you wrote in the previous lesson. Note that we added some functionality to the `PokemonDetailViewController` that allows us to switch to an _editing state_ in which we can change the name and image URL using the corresponding text fields. However, any changes that we make right now will have no effect in our backend - that's what we want to implement in this exercise.


## Updating An Existing Pokemon

### Defining An `UpdatePokemonMutation` 

As a first step, we want to implement update functionality for our Pokemons. This will be done through a mutation that we need to define upfront. Since the mutation will only be used inside the `PokemonDetailViewController`, now is a good time to create a new `.graphql` file that contains all queries/mutations for the `PokemonDetailViewController`. As before, create a new _empty_ file in Xcode and call it `PokemonDetailViewController.graphql`. Then, copy the following mutation into it:

```graphql@PokemonDetailViewController.graphql
mutation UpdatePokemon($id: ID!, $name: String!, $url: String!) {
  updatePokemon(id: $id, name: $name, url: $url) {
    ... PokemonDetails
  }
}
```

Note that if we hadn't made `$name` and `$url` required, the user of this mutation might not provide a value for either of them which would delete the value for the field with a missing parameter. So, here we require both values to prevent the user from accidentally deleting them.

Build the project by pressing `CMD + B` and inspect `API.swift`. Notice that a new class called `UpdatePokemonMutation` has been created. Let's go and use it right away!


### Using The `UpdatePokemonMutation` 

In `PokemonDetailViewController.swift`, copy the following code snippet into `editAndSaveButtonPressed()`:

```swift@PokemonDetailViewController.swift
if isEditingPokemon {
    // make sure required data is available
    guard let name = nameTextField.text, name.characters.count > 0,
        let url = imageURLTextField.text, url.characters.count > 0,
        let id = pokemonDetails?.id else {
            print(#function, "ERROR | Missing data")
            return
    }
    
    // start activity indicator
    saveActivityIndicator.startAnimating()

    // actually perform the mutation
    let updatePokemonMutation = UpdatePokemonMutation(id: id, name: name, url: url)
    apollo.perform(mutation: updatePokemonMutation) { [unowned self] result, error in
        if let error = error {
            print(#function, "ERROR | Could not update Pokemon: (\(error))")
        }
        else if let pokemonDetails = result?.data?.updatePokemon?.fragments.pokemonDetails {
            self.pokemonDetails = pokemonDetails
            self.saveActivityIndicator.stopAnimating()
            self.isEditingPokemon = !self.isEditingPokemon
        }
    }
}
else {
    isEditingPokemon = !isEditingPokemon
}
```

That's a lot of code, let's try to understand what it does! In the very beginning, we check if we're currently in the _editing state_ - if that is the case we are going to perform the mutation using the strings that are written in the text fields. Therefore, we first make sure that the required data is provided using a `guard` statement. We then start the activity indicator to indicate to the user that a network request has started. Finally, we instantiate the `UpdatePokemonMutation` that was generated by `apollo-codegen` based on the mutation we added in `PokemonDetailViewController.graphql`. Subsequently, we call `perform` on our `ApolloClient` instance passing the instance of the mutation as well as a callback to deal with the return value. Since we are using our `PokemonDetails` fragment again, we can simply extract this from the return value inside the callback and assign it the `pokemonDetails` property. This will automatically update the UI because of the `didSet` property observer. 

Go ahead and test the new feature by modifying the name or image URL of one of the Pokemons in your Pokedex. You should see the UI being updated with the new values after a successful completion of the mutation. 

Thanks to the caching and automatic update functionality that we saw in the previous exercise, you'll also see the updated Pokemon data in the table view if you navigate back to the `PokedexTableViewController`. Let's now add the final bit of functionality which is to delete a Pokemon.


## Deleting An Existing Pokemon

### Defining A `DeletePokemonMutation` 

In order to delete a Pokemon, we will need another mutation. Add the following mutation to your existing `PokemonDetailViewController.graphql` file:

```graphql@PokemonDetailViewController.graphql
mutation DeletePokemon($id: ID!) {
    deletePokemon(id: $id) {
        trainer {
            id
            ownedPokemons {
                id
            }
        }
    }
}
```

Notice that this time we're explicitly asking for the `trainer` and the associated `ownedPokemons` again, just like with the `CreatePokemon` mutation. That is so that the automatic UI updates work! If we didn't ask for this data to be returned from the mutation, our `trainerQueryWatcher` wouldn't notice that the data in the store changed and wouldn't run the result handler again.


### Using the `DeletePokemonMutation`

Now, as we have the `DeletePokemonMutation` available, let's go ahead and use it to enable deleting Pokemons from the Pokedex. In `PokemonDetailViewController.swift`, copy the following snippet into `deleteButtonPressed()` 

```swift@PokemonDetailViewController.swift
deleteActivityIndicator.startAnimating()
let deleteMutation = DeletePokemonMutation(id: pokemonDetails.id)
apollo.perform(mutation: deleteMutation) { [unowned self] result, error in
    self.deleteActivityIndicator.stopAnimating()
    if let error = error {
        print(#function, "ERROR | Could not delete Pokemon: (\(error))")
    }
    else {
        print("Successfully deleted Pokemon with ID: \(result?.data?.deletePokemon?.id)")
        let _ = self.navigationController?.popViewController(animated: true)
    }
}
```

Similar to our mutations before, we first instantiate the `DeletePokemonMutation`, providing the right arguments to its initializer, and then pass it as an argument to the `perform` call on our `ApolloClient` instance. This time, upon success, the callback will print that the Pokemon was deleted and navigate back to the previous view controller.


## Recap

**Congratulations, you have implemented the last bit of functionality for this tutorial!** ðŸš€ 

Let's recap what we learned in this last lesson:
- Mutations for updating and deleting existing data entries are syntactially similar to mutations for adding new data entries
- The returned result of a mutation may contain any data that we specify in the mutation - we can conveniently use this data to update the UI




