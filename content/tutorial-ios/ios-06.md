# Tutorial 06 - More Mutations

Welcome to the 6th exercise in the **iOS Track** of this Apollo Client Tutorial!


## Goal

The **goal** of this exercise is to implement features for updating and deleting existing Pokemons from the Pokedex. This will give you more familiarity with using mutations.


## Introduction

Open the directory that contains the 6th exercise (`exercise-06`) and open `pokedex-apollo.xcworkspace`. It already contains a running version of the code you wrote in the previous lesson. Note that we added some functionality to the `PokemonDetailViewController` that allows us to switch to an _editing state_ in which we can change the name and image URL using the corresponding text fields. However, any changes that we make right now will have no effect - that's what we want to implement in this exercise.


## Updating An Existing Pokemon

### Defining An `UpdatePokemonMutation` 

As a first step, we want to implement update functionality for our Pokemons. This will be done through a mutation that we need to define upfront. Since the mutation will only be used inside the `PokemonDetailViewController`, now is a good time to create a new `.graphql` file that contains all queries/mutations for the `PokemonDetailViewController`. As before, create a new _empty_ file in Xcode and call it `PokemonDetailViewController.graphql`. Then, copy the following mutation into it:

```graphql
mutation UpdatePokemon($id: ID!, $name: String!, $url: String!) {
  updatePokemon(id: $id, name: $name, url: $url) {
    ... PokemonDetails
  }
}
```

Note that if we hadn't made `$name` and `$url` mandatory, the user of this mutation might not provide a value for either of them which would delete the value for the field with a missing parameter. So, here we require both values to prevent the user from accidentally deleting them.

Build the project by pressing `CMD + B` and inspect `API.swift`. Notice that a new class called `UpdatePokemonMutation` has been created. Let's go and use it right away!


### Using The `UpdatePokemonMutation` 

In `PokemonDetailViewController.swift`, copy the following code snippet into `editAndSaveButtonPressed()` replacing the current line:

```swift
if isEditingPokemon {
    // make sure required data is available
    guard let name = nameTextField.text, name.characters.count > 0,
        let url = imageURLTextField.text, url.characters.count > 0,
        let id = pokemonDetails?.id else {
            print(#function, "ERROR | Missing data")
            return
    }
    
    // start activity indicator
    saveActivityIndicator.startAnimating()

    // actually perform the mutation
    let updatePokemonMutation = UpdatePokemonMutation(id: id, name: name, url: url)
    apollo.perform(mutation: updatePokemonMutation) { [unowned self] result, error in
        if let error = error {
            print(#function, "ERROR | Could not update Pokemon: (\(error))")
        }
        else if let pokemonDetails = result?.data?.updatePokemon?.fragments.pokemonDetails {
            self.pokemonDetails = pokemonDetails
            self.saveActivityIndicator.stopAnimating()
            self.isEditingPokemon = !self.isEditingPokemon
        }
    }
}
else {
    isEditingPokemon = !isEditingPokemon
}
```

That's a lot of of code, let's try to understand what it does! In the very beginning, we check if we're currently in the _editing state_ - if that is the case we are going to perform the mutation using the strings that are written in the text fields. Therefore, we first make sure that the required data is provided using a `guard` statement. We then start the activity indicator to indicate to the user that a network request has started. Finally, we instantiate the `UpdatePokemonMutation` that was generated by `apollo-codegen` based on the mutation we added in `PokemonDetailViewController.graphql`. Subsequently, we call `perform` on our `ApolloClient` instance passing the instance of the mutation as well as a callback to deal with the return value. Since we are using our `PokemonDetails` fragment again, we can simply extract this from the return value inside the callback and assign it the `pokemonDetails` property. This will automatically update the UI because of the `didSet` property observer. 

Go ahead and test the new feature by modifying the name or image URL of one of the Pokemons in your Pokedex. You should see the UI being updated with the new values after a successful completion of the mutation. However, once again, if we navigate back to the `PokedexTableViewController`, the changes won't be reflected in the table view yet.


### Updating The UI

That is because the data in the `ownedPokemons` array in `PokedexTableViewController` is independent from the data we just updated in `PokemonDetailViewController`, so we have to manually update it. Let's do so again with a closure. Add the following property to `PokemonDetailViewController`:

```swift
var updatedPokemon: ((PokemonDetails) -> ())?
``` 

Then, call the closure in `viewWillDisappear(_ animated: Bool)` like so:

```swift
override func viewWillDisappear(_ animated: Bool) {
    super.viewWillDisappear(animated)
    updatedPokemon?(pokemonDetails)
}
```

Finally, assign the closure in `prepare(for segue: UIStoryboardSegue, sender: Any?)` in `PokedexTableViewController`:

```swift
pokemonDetailViewController.updatedPokemon = { [unowned self] pokemonDetails in
    if let index = self.ownedPokemons?.index(where: { pokemonDetailsInArray in
        return pokemonDetailsInArray.id == pokemonDetails.id
    }) {
        self.ownedPokemons?[index] = pokemonDetails
    }
}
```

We first search for the right `PokemonDetails` in the `ownedPokemons` array and then replace it with the updated instance.

Great, that was all you need in order to make sure the updated Pokemon data is reflected in the table view when navigating back! Let's now add the final bit of functionality which is to delete a Pokemon.


## Deleting An Existing Pokemon

### Defining A `DeletePokemonMutation` 

In order to delete a Pokemon, we will need another mutation. Add the following mutation to your existing `PokemonDetailViewController.graphql` file:

```graphql
mutation DeletePokemon($id: ID!) {
  deletePokemon(id: $id) {
    id
  }
}
```

This time, since we are deleting the Pokemon, we don't have to ask for more than the ID of the deleted Pokemon as a return value. Build the project by pressing `CMD + B` and then take a quick look at `API.swift` where you'll see the `DeletePokemonMutation` class being generated as expected.


### Using the `DeletePokemonMutation`

Now, as we have the `DeletePokemonMutation` available, let's go ahead and use it to enable deleting Pokemons from the Pokedex. In `PokemonDetailViewController.swift`, copy the following snippet into `deleteButtonPressed()` 

```swift
deleteActivityIndicator.startAnimating()
let deleteMutation = DeletePokemonMutation(id: pokemonDetails.id)
apollo.perform(mutation: deleteMutation) { [unowned self] result, error in
    self.deleteActivityIndicator.stopAnimating()
    if let error = error {
        print(#function, "ERROR | Could not delete Pokemon: (\(error))")
    }
    else {
        print("Successfully deleted Pokemon with ID: \(result?.data?.deletePokemon?.id)")
        let _ = self.navigationController?.popViewController(animated: true)
    }
}
```

Similar to our mutations before, we first instantiate the `DeletePokemonMutation`, providing the right arguments to its initializer, and then pass it as an argument to the `perform` call on our `ApolloClient` instance. This time, upon success, the callback will print that the Pokemon was deleted and navigate back to the previous `PokedexTableViewController`.

However, when testing the feature, once again you'll notice that the table view doesn't update automatically and the deleted Pokemon will stick around unless you completely restart the app. So, let's fix that!


### Updating The UI

Using a similar approach as before, first add a property to the `PokemonDetailViewController`:

```swift
var deletedPokemon: ((GraphQLID) -> ())?
```

Next, replace the `print` statement in the callback with a call to the closure:

```swift
if let error = error {
    print(#function, "ERROR | Could not delete Pokemon: (\(error))")
}
else {
    if let pokemonId = result?.data?.deletePokemon?.id {
        deletedPokemon?(pokemonId)
        let _ = self.navigationController?.popViewController(animated: true)
    }
}
```

The last step is to assign the closure in `PokedexTableViewController`, so add the following code in `prepare(for segue: UIStoryboardSegue, sender: Any?)`:

```swift
pokemonDetailViewController.deletedPokemon = { [unowned self] id in
    self.ownedPokemons = self.ownedPokemons?.filter { ownedPokemon in
        ownedPokemon.id != id
    }
}
```

All right, you can now go and test deleting Pokemon from your Pokedex. After a successful deletion, the table view should automatically update!


## Recap

Congratulations, you have implemented the last bit of functionality for this tutorial! ðŸš€ Let's recap what we learned in this lesson:
- Mutations for updating and deleting existing data entries are syntactially similar to mutations for adding new data entries as well to queries
- The result of a mutation can contain any data that we specify - we can conveniently this data to update the UI




