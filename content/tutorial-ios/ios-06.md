# Tutorial 06 - More Mutations

Welcome to the sixth exercise in the **iOS Track** of this Apollo Client Tutorial!


## Goal

The **goal** of this exercise is to implement features for updating and deleting existing Pokemons in the Pokedex. This will give you more familiarity with using mutations.


## Introduction

Open the directory that contains the fifth exercise `exercise-05` and open `pokedex-apollo.xcworkspace`. It already contains a running version of the code you wrote in the previous lesson. Note that we added some functionality to the `PokemonDetailViewController` that allows us to switch to an _editing state_ in which we can change the name and image URL using the corresponding text fields. However, any changes that we make right now will have no effect - that's what we want to implement in this exercise.

## Updating an Existing Pokemon

### Defining an `UpdatePokemonMutation` 

As a first step, we want to implement update functionality for our Pokemons. This will be done through a mutation that we need to define upfront. Since the mutation will only be used inside the `PokemonDetailViewController`, now is a good time to create a new `.graphql` file that contains all queries/mutations for the `PokemonDetailViewController`. As before, create a new _empty_ file and call it `PokemonDetailViewController.graphql`. Then, copy the following mutation into it:

```graphql
mutation UpdatePokemon($id: ID!, $name: String!, $url: String!) {
  updatePokemon(id: $id, name: $name, url: $url) {
    ... PokemonDetails
  }
}
```

Note that if we didn't make `$name` and `$url` mandatory, the user of this mutation might not provide a value for either of them and thus actually delete the value for this field. So, here we require both values to prevent the user from accidentally resetting them.

Build the project by pressing `CMD + B` and inspect `API.swift`. Notice that a new class called `UpdatePokemonMutation` has been created. Let's go and use it right away!


### Using the `UpdatePokemonMutation` 

In `PokemonDetailViewController.swift`, copy the following code snippet into `editAndSaveButtonPressed()` replacing the current line:

```swift
if isEditingPokemon {
    // make sure required data is available
    guard let name = nameTextField.text, name.characters.count > 0,
        let url = imageURLTextField.text, url.characters.count > 0,
        let id = pokemonDetails?.id else {
            print(#function, "ERROR | Missing data")
            return
    }
    
    // start activity indicator
    saveActivityIndicator.startAnimating()

    // actually perform the mutation
    let updatePokemonMutation = UpdatePokemonMutation(id: id, name: name, url: url)
    apollo.perform(mutation: updatePokemonMutation) { [unowned self] result, error in
        if let error = error {
            print(#function, "ERROR | Could not update Pokemon: (\(error))")
        }
        else if let pokemonDetails = result?.data?.updatePokemon?.fragments.pokemonDetails {
            self.pokemonDetails = pokemonDetails
            self.saveActivityIndicator.stopAnimating()
            self.isEditingPokemon = !self.isEditingPokemon
        }
    }
}
else {
    isEditingPokemon = !isEditingPokemon
}
```

That's a lot of of code, let's try to understand what it does! In the very beginning we check if we're currently in the _editing state_ -  if that is the case we are actually performing the mutation using the data that is contained in the text fields. Therefore, we first make sure that the required data is provided using a `guard` statement. We then start the activity indicator to indicate to the user that a network request has started. Finally, we instantiate the `UpdatePokemonMutation` that was generated by `apollo-codegen` based on the mutation we added in `PokemonDetailViewController.graphql`. Subsequently, we call `perform` on our `apollo` instance passing the instance of the mutation as well as a callback to deal with the return value. Since we are using our `PokemonDetails` fragment again, we can simply extract this from the return value inside the callback and assign it the `pokemonDetails` property which will automatically update the UI through the `didSet` property observer. 

Go ahead and test the new feature by modifying the name or image URL of one of the Pokemons in your Pokedex. You should the UI being updated with the new values after a successful completion of the mutation. However, once again, if we navigate back to the table view the table view won't be updated.


### Updating the UI

That is because the data in the `ownedPokemons` array in `PokedexTableViewController` is independent from the data we just updated in `PokemonDetailViewController`, so we have to manually update it. Let's do so again with a closure, add the following property to `PokemonDetailViewController`:

```swift
var updatedPokemon: ((PokemonDetails) -> ())?
``` 

Then, call the closure in `viewWillDisappear` like so:

```swift
override func viewWillDisappear(_ animated: Bool) {
    super.viewWillDisappear(animated)
    updatedPokemon?(pokemonDetails)
}
```

Finally, assign the closure in `prepare(for segue: UIStoryboardSegue, sender: Any?)` in `PokedexTableViewController`:

```swift
pokemonDetailViewController.updatedPokemon = { [unowned self] pokemonDetails in
    if let index = self.ownedPokemons?.index(where: { pokemonDetailsInArray in
        return pokemonDetailsInArray.id == pokemonDetails.id
    }) {
        self.ownedPokemons?[index] = pokemonDetails
    }
}
```

We first search for the right `PokemonDetails` in the `ownedPokemons` array and then replace it with the updated instance.

Great, that was all you needed in order to make sure updated Pokemon data is reflected in the table view when navigating back! Let's now add the final bit of functionality which is to delete a Pokemon.


## Deleting an Existing Pokemon

### Defining a `DeletePokemonMutation` 

In order to delete a Pokemon, we will need another mutation. Add the following mutation to your existing `PokemonDetailViewController.graphql` file:

```graphql
mutation DeletePokemon($id: ID!) {
  deletePokemon(id: $id) {
    id
  }
}
```

This time, since we are deleting the Pokemon, we don't have to ask for more than the ID of the deleted Pokemon.

Build the project by pressing `CMD + B` and then take a quick look at `API.swift` where you'll see the `DeletePokemonMutation` being generated as expected.


### Using the `DeletePokemonMutation`

Now, as we have the `DeletePokemonMutation` available, let's go ahead and use it to enable deleting Pokemons from your Pokedex. In `PokemonDetailViewController`, copy the following snippet into `deleteButtonPressed()` 

```swift
deleteActivityIndicator.startAnimating()
let deleteMutation = DeletePokemonMutation(id: pokemonDetails.id)
apollo.perform(mutation: deleteMutation) { [unowned self] result, error in
    self.deleteActivityIndicator.stopAnimating()
    if let error = error {
        print(#function, "ERROR | Could not delete Pokemon: (\(error))")
    }
    else {
        print("Successfully deleted Pokemon with ID: \(result?.data?.deletePokemon?.id)")
        let _ = self.navigationController?.popViewController(animated: true)
    }
}
```

Similar to our mutations before, we first instantiate the `DeletePokemonMutation`, providing the right arguments to its initializer, and then pass it to a call to `perform` on our `ApolloClient` instance. This time, upon success, the callback will print that the Pokemon was deleted and navigate back to the previous `PokedexTableViewController`.

However, when testing the feature, once again you'll notice that the table view doesn't update automatically and the deleted Pokemon will stick around unless you completely restart the app. So, let's fix that!


### Updating the UI

Using a similar approach as before, first add a property to the `PokemonDetailViewController`:

```swift
var deletedPokemon: ((GraphQLID) -> ())?
```

Next, replace the `print` statement in the callback with a call to the closure:

```swift
if let error = error {
    print(#function, "ERROR | Could not delete Pokemon: (\(error))")
}
else {
    if let pokemonId = result?.data?.deletePokemon?.id {
        deletedPokemon?(pokemonId)
        let _ = self.navigationController?.popViewController(animated: true)
    }
}
```

The last step is to assign the closure in `PokedexTableViewController`, so add the following code in `prepare(for segue: UIStoryboardSegue, sender: Any?)`:

```swift
pokemonDetailViewController.deletedPokemon = { [unowned self] id in
    self.ownedPokemons = self.ownedPokemons?.filter { ownedPokemon in
        ownedPokemon.id != id
    }
}
```

All right, oyu can now go and test deleting Pokemon from your Pokedex. After a successful deletion, the table view should automatically update!


## Recap

Congratulations, you have implemented the last bit of functionality for this tutorial! ðŸš€ Let's recap what we learned in this lesson:
- Mutations for updating and deleting existing data entries are syntactially similar to mutations for adding new data entries as well to queries
- The result of a mutation can contain any data that we specify - we can conveniently this data to update the UI




